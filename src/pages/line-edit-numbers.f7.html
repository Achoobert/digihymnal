<template>
    <div class="page">
        <div class="navbar">
            <div class="navbar-bg"></div>
            <div class="navbar-inner sliding">
                <div class="left">
                    <a {{#if loading}}href=""{{else}}href="/song/view/{{this.songId}}/"{{/if}} class="link back" data-force="true" data-ignore-cache="true">
                        <i class="icon icon-back"></i> 
                        <span class="if-not-md" >{{#if loading}}Back{{else}}{{translate "Back"}}{{/if}}</span>
                    </a>
                </div>
                <div class="title">{{#if loading}}{{else}} {{song.title[defaultLanguage]}} : {{@root.verseLabel}} {{/if}}</div>
            </div>
        </div>
        <div class="page-content hide-navbar-on-scroll">
            {{#js_if "!@root.loading"}}
                <div class="block block-strong" style="margin-bottom: 10px; overflow: hidden;">
                    <div class="menu">
                        <div class="menu-inner no-margin-padding">
                            <!-- Stepper element -->
                            <div class="stepper stepper-large stepper-fill" style="display: none; margin-left: auto; height: 40px;">
                                <div class="stepper-button-minus"></div>
                                <div class="stepper-input-wrap">
                                    <input type="text" value="{{transpose song.key @root.steps}}" readonly>
                                </div>
                                <div class="stepper-button-plus"></div>
                            </div>
                            <div>
                                <div class="menu-item">
                                    <div class="menu-item-content icon-only">
                                        <div class="menu-item-content">
                                            <a @click="save" class="col button button-fill">
                                                <i class="text-color-gray fa-bigger fas fa-save"></i>
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a class="col button button-fill{{#if firstLine}} disabled{{/if}}" @click="prevLine">
                                            <i class="text-color-gray fas fa-bigger fa-arrow-left"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                            goto next
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="nextLine" class="col button button-fill{{#js_if "@root.lastLine && @root.lastVerse"}} disabled{{/js_if}}">
                                            <i class="text-color-gray fa-bigger fas fa-arrow-right"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="item-title item-label">
                                Number tools:
                            </div>
                            <!--
                                phrase
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="addPhrase" class="col button">
                                            <i class="text-color-gray fas fa-plus"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                                delete phrase, only show if totally empty??????
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="deletePhrase" class="col button">
                                            <i class="text-color-gray fas fa-trash"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                            LINE
                            -->
                            <!-- <div class="item-title item-label">
                                <t>Line tools:</t>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="addLine" class="col button button-fill">
                                            <i class="text-color-gray fa-bigger fas fa-plus"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a class="col button button-fill" @click="deleteLine">
                                            <i class="text-color-gray fa-bigger fas fa-trash"></i>
                                        </a>
                                    </div>
                                </div>
                            </div> -->
                        </div>
                    </div>

                    <div class="sheet">
                        <div class="song">
                            <div class="verse">
                                <div class="line" id="edit-line">
                                    <!-- -->
                                    {{ printEachNumber @root.line }}
                                    <!-- -->
                                    {{ printLyric @root.line}}
                                </div>
                            </div>
                        </div>
                    </div>
                {{#js_if "@root.savable"}}
                    <p><a @click="save"  class="col popup-close button button-fill">*Save</a></p>
                {{/js_if}}
                </div>
                <div class="block text-align-right text-color-gray" style="margin-top: 10px;">
                    {{song.author[defaultLanguage]}}
                </div>
            {{/js_if}}
        </div>
    </div>
</template>
<style>
    .noUi-marker {
        height: 0 !important;
    }

    .no-margin-padding {
        margin: 0;
        padding: 0;
    }

    .fa-bigger {
        font-size: larger;
    }

    .song {
        transform-origin: left top;
    }

    .line {
        margin-bottom: 20px;
    }

    .phrase {
        position: relative;
        display: inline-block;
        margin: 55px 10px 0 0;
        min-width: 20px;
    }

    .chord,
    .number {
        top: -55px;
        background: var(--f7-theme-color);
        border-radius: 3px;
        min-width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        color: white;
        font-weight: bold;
        display: inline-block;
        padding: 0 2px;
        margin-right: 5px;
        position: absolute;
        padding: 2px;
    }

    .number {
        top: -25px;
        border-radius: 100%;
        width: 20px;
        height: 20px;
        padding: 2px;
        background: var(--f7-color-blue);
        font-family: 'Notes', monospace;
    }

    .noNumbers,
    .noChords {
        margin-top: 30px !important;
    }

    .noNumbers.noChords {
        margin-top: 10px !important;
    }

    .noNumbers .chord,
    .noChords .chord {
        top: -30px;
    }
</style>
<script>
    var songId
    var loading
    var savable = false;
    var verseId
    var verseLabel
    var lineId
    var languages
    var lyricList
    var line
    var song
    var app
    var lastVerse
    var lastLine
    var firstLine
    var numberStartLocations
    var numberArray = [];
    import DataManager from '../data/dataManager';
    import Song from '../data/song';
    import LineModulate from '../data/lineModulate';
    import noUiSlider from 'nouislider';
    import 'nouislider/dist/nouislider.css';

    // //  the namespace:
    // import * as noUiSlider from 'nouislider';
    // import 'nouislider/dist/nouislider.css';
    
    // // Alternatively, you can include both files:
    // <link href="nouislider.css" rel="stylesheet">
    // <script src="nouislider.js"><//////script>
        
    import Preference from "../data/preference";
    const dataManager = new DataManager();
    const songCollection = new Song();
    const lineModulate = new LineModulate();
    const preference = new Preference();
    import ParseText from "../data/parseText";
    const parseText = new ParseText();

    // Import locales
    const locale = require('../js/locales.js');

    var initScale = 1;
    var lyric1;
    var lyric2;
    var defaultLanguage;
    var deviceWidth = window.innerWidth;
    var self = this;
    if (deviceWidth >= 700) {
        initScale = 2;
    } else if (deviceWidth >= 500) {
        initScale = 1.5;
    }
    var steps = 0;

    export default {
        // Component Data
        data: function() {
            // Must return an object
            self = this;
            return {
                loading: true,
                savable: savable,
                lastVerse: false,
                lastLine: false,
                firstLine: false,
                showNumber: false,
                showChord: false
            }
        },
        // Page Events
        on: {
            pageInit: function(e, page) {
                self = this;
                app = self.$app;
                var $form = this.$('#edit-line')
                
                songId = this.$route.params.songId;
                verseId = this.$route.params.verseId;
                lineId = this.$route.params.lineId;
                
                // get global savable
                self.savableUpdate(app.savable);

                preference.getLanguage().then((languageCode) => {
                    lyric1 = languageCode;
                    defaultLanguage = languageCode;
                    languages = [];
                    lyricList = []
                    var result = app.song;
                    var translationLangs = Object.keys(result.lyrics.verses[verseId].lines[lineId].phrases[0]);
                    //var translationLangs = Object.keys(result.title);
                    locale.customLocales.forEach((item) => {
                        if (translationLangs.indexOf(item.tag) > -1) {
                            if (item.tag == lyric1) {
                                item.default = true;
                            }
                            languages.push(item.tag)
                        }
                    });
                    line = result.lyrics.verses[verseId].lines[lineId]

                    // check if last line
                    lastLine = (lineId >= (result.lyrics.verses[verseId].lines.length - 1));
                    lastVerse = (verseId >= (result.lyrics.verses.length - 1));
                    // song is used to get next line
                    song = result

                    self.$setState({
                        loading: false,
                        savable: savable,
                        songId: songId,
                        lastLine: lastLine,
                        lastVerse: lastVerse,
                        verseLabel: result.lyrics.verses[verseId].label,
                        firstLine: (lineId == 0 && verseId == 0),
                        song: song,
                        // verse: result.verse[verseId],
                        line: line,
                        steps: steps,
                        languages: languages,
                        lyricList: lyricList,
                        defaultLanguage: defaultLanguage
                    }, () => {
                        self.$(".song")[0].style.transform = "scale(" + initScale + ")";
                        self.$(".sheet")[0].style.height = (self.$(".song")[0].offsetHeight * initScale) + "px";

                        // make the sliders
                        self.displayLyricSliders()

                        languages.forEach(lang => {
                            line.phrases.forEach(phrase => {
                                lyricList.push({
                                    "tag": lang,
                                    "lyric": line[lang]
                                })
                            });
                        });

                        var stepper = app.stepper.create({
                            el: '.stepper',
                            value: steps,
                            min: 0,
                            max: 11,
                            wraps: true,
                            on: {
                                change: function(e) {
                                    steps = e.value;
                                    self.$setState({
                                        steps: steps,
                                    });
                                }
                            }
                        });
                    });
                });
            },
        },
        methods: {
            zoomIn: function(e) {
                initScale += 0.05;
                this.$(".song")[0].style.transform = "scale(" + initScale + ")";
                this.$(".sheet")[0].style.height = (this.$(".song")[0].offsetHeight * initScale) + "px";
            },
            zoomOut: function(e) {
                initScale -= 0.05;
                this.$(".song")[0].style.transform = "scale(" + initScale + ")";
                this.$(".sheet")[0].style.height = (this.$(".song")[0].offsetHeight * initScale) + "px";
            },
            save: function(e) {
                var $form = this.$('#edit-line')
                var $ = $form.find("select[name='']") //relation
                if (!self.$app.input.validateInputs('#edit-line')) {
                    // TODO make this say what the error is
                    self.$app.dialog.alert('Please correct your entries.');
                    console.error('<t>Please correct your entries.</t>');
                } else {
                    let newData = song; 
                    var metaIndex = 0 
                    while ( metaIndex < newData.lyrics.verses[verseId].lines[lineId].phrases.length ){
                        let id = ('.number').concat(metaIndex)
                        let number = self.$(id)[0]//.value // self.$('.number1').firstElementChild.value
                        if (number) { // our template will not create form if it's supposed to be blank
                            // setting number
                            let number = self.$(id)[0].value 
                            numberArray.push(number)
                        } 
                        metaIndex++;
                    }
                    
                    var newLineCombined = [];
                    languages.forEach(langTag => { // selected language
                        newLineCombined = lineModulate.combineLines(newLineCombined, self.parseLanguageText(langTag));
                    });  

                    newData.lyrics.verses[verseId].lines[lineId].phrases = newLineCombined;
                    newData.lyrics.verses[verseId].lines[lineId].numbers = numberArray;
                    // // this only updates the numbers, **if the nouisliders were not modified** this would be a fast way of updating just the notes
                    // var metaIndex = 0;
                    // var phraseIndex = 0;

                    // while (phraseIndex < newData.lyrics.verses[verseId].lines[lineId].phrases.length) {
                    //     if(newData.lyrics.verses[verseId].lines[lineId].phrases[phraseIndex].number){
                    //         let id = ('.number').concat(metaIndex)
                    //         let number = self.$(id)[0]//.value // self.$('.number1').firstElementChild.value
                    //         if (number) { // our template will not create form if it's supposed to be blank
                    //             // setting number
                    //             let number = self.$(id)[0].value 
                    //             newData.lyrics.verses[verseId].lines[lineId].phrases[phraseIndex]['number'] = number
                    //         }
                    //         metaIndex ++;
                    //     }
                    //     phraseIndex++;
                    // };
                    
                    // save
                    line = {'phrases':newLineCombined};
                    song = newData;
                    app.song = newData;
                    //songCollection.db.setItem(songId, newData);
                    self.savableUpdate(false);
                    self.clearSliders();
                    self.$setState({
                        loading: false,
                        song: newData,
                        line: newData.lyrics.verses[verseId].lines[lineId]
                    }, () => {
                        self.displayLyricSliders();
                    });
                    // send line changes to server
                    // dataManager.putLine(songId, verseId, lineId, newData.lyrics.verses[verseId].lines[lineId])
                    //     .then(responseText => alert(JSON.stringify(responseText)));
                    // send whole song to server
                    // dataManager.putSong(songId, newData)
                    //  .then(responseText => alert(JSON.stringify(responseText)));
                
                }
            },
            // make phraseList 
            parseLanguageText: function(tag, languageArr, insertArray, chordMap){
                // I need the full string "Twinkle, twinkle, little star"
                // I need placment of phrase breaks ["0.00", "10.00", "15.00"]
                // make phrases list:
                var phraseArray = [] ;
                // [(en:'Twinkl%e, tw'),(chord:'A',en:'ink%le'),(chord:'E',en:', litt%le star%%%'),(chord:'D',en:'%%%')] 
                if(!insertArray){ // get from dom
                    try {
                        insertArray = this.$$(`#slider-${tag}`)[0].noUiSlider.get()
                    } catch (error) {
                        console.error(error)
                    }
                    if (!insertArray) {
                        console.error({"no div for tag":tag})
                    }
                }
                var numberMap = [];
                insertArray.forEach(element => {
                    numberMap.push( parseInt(element) );
                });
                if(!languageArr){ // get from global var
                    try {
                        languageArr = []
                        chordMap = []
                        var languageLen = 0
                        var lastLength = 0
                        var first = true;
                        line.phrases.forEach(phrase => {
                            if (Object.hasOwnProperty.call(phrase, tag)) {
                                let arr = lineModulate.diacriticCheckerChord(phrase[tag], 0);
                                languageArr = languageArr.concat(arr)
                                languageLen += arr.length
                            } 
                            let phraseMap = {}
                            if (Object.hasOwnProperty.call(phrase, 'chord')) { // has chord
                                phraseMap['len'] = lastLength // we get distance from start
                                lastLength = languageLen
                                phraseMap['chord'] = phrase['chord']
                                chordMap.push(phraseMap)
                            } else if ( !Object.hasOwnProperty.call(phrase, 'chord') && first ) { 
                                // first phrase is chordless,
                                phraseMap['len'] = 0 // is start
                                lastLength =  languageLen
                                phraseMap['chord'] = ''
                                chordMap.push(phraseMap)
                            }

                            first = false;
                        });
                    } catch (error) {
                        console.error(error)
                    }
                    if (!languageArr) {
                        console.error({"no line data for tag":tag});
                    }
                }

                if (typeof insertArray === 'string'){// there's only the one number 
                    let numberLoc = parseInt(insertArray)
                    languageArr[numberLoc] = String.fromCharCode(173).concat(languageArr[numberLoc]) 
                    e[tag] = languageArr.join('');
                    phraseArray.push(e)
                } else {
                    var firstChord = true;

                    var i = 0;
                    console.log(chordMap) // this is the expected map
                    console.log(languageArr) // lyrics with number markers NOT messing in indexes

                    // from JSON
                    // chordMap
                    // from nouislider
                    // insertArray
                    //if(tag == 'en'){debugger}
                    var chordMapi = 0
                    var first = true;

                    
                    numberMap.forEach((element) => {
                        if ( element < languageArr.length ){
                            //languageArr[element] = String.fromCharCode(173).concat(languageArr[element]) ; // 
                            languageArr[element] = "%".concat(languageArr[element]) ; 
                        } else { //put it into last
                            languageArr.push("%".concat(String.fromCharCode(173)))
                        }
                    });
                }
                if (chordMap){
                    while(chordMap[chordMapi]){ 
                        let currentChord = chordMap[chordMapi];
                        let phraseLen = ( chordMap[chordMapi+1]? (chordMap[chordMapi+1].len-currentChord.len) : languageArr.length ); // sub next len from curr lent to get expected strong. if no next get whole string
                        let e = {}

                        if( first ){
                            // phrase 0 can lack a chord/num, if it does, we show it via ''
                            if ( currentChord['chord'] != '' ){
                                e.chord = currentChord.chord;
                            }
                            if ( phraseLen > 0) {
                                e[tag] = languageArr.splice(0,phraseLen).join('')
                            } 
                            first = false;
                        } else { 
                            e.chord = currentChord.chord
                            e[tag] = languageArr.splice(0,phraseLen).join('')
                        }
                        chordMapi++
                        phraseArray.push(e)
                    }
                } else { //
                    // no chords????
                    debugger//?
                }
                if(tag == 'en'){
                    console.log({'new line': phraseArray, 'old line':line.phrases});
                    debugger
                }
                return phraseArray;
            },
            nextLine: function(e) {
                // only get index forward if it exists in song
                if (lastLine && !lastVerse) { // if at end of NOTlastVerse, check next verse
                    lastVerse = ((verseId + 1) >= (song.lyrics.verses.length - 1)); // is next verse last verse?
                    lastLine = ((song.lyrics.verses[parseInt(verseId) + 1].lines[1]) == undefined); // is there only one line in next verse?
                    ++verseId;
                    lineId = 0;
                    verseLabel = song.lyrics.verses[verseId].label;
                } else {
                    // check if last line
                    lastLine = ((lineId + 1) >= (song.lyrics.verses[verseId].lines.length - 1));
                    ++lineId;
                }
                // update variable
                line = song.lyrics.verses[verseId].lines[lineId]
                self.clearSliders()
                self.$setState({
                    loading: false,
                    firstLine: (lineId == 0 && verseId == 0),
                    lastLine: lastLine,
                    lastVerse: lastVerse,
                    verseLabel: verseLabel,
                    line: song.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.clearSliders()
                    self.displayLyricSliders()
                });
            },
            prevLine: function(e) {
                if (lineId == 0) {
                    --verseId
                    lineId = song.lyrics.verses[verseId].lines.length - 1
                    // update variable
                    lastVerse = ((verseId) >= (song.lyrics.verses.length - 1)); // is next verse last verse?
                    verseLabel = song.lyrics.verses[verseId].label;
                } else {
                    --lineId
                }
                line = song.lyrics.verses[verseId].lines[lineId]
                self.clearSliders()
                self.$setState({
                    loading: false,
                    firstLine: (lineId == 0 && verseId == 0),
                    lastLine: false,
                    verseLabel: verseLabel,
                    lastVerse: lastVerse,
                    line: song.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            addPhrase: function(e) {
                let newData = song
                // At index, add one element

                var phraseArray = newData.lyrics.verses[verseId].lines[lineId].phrases
                var workingIndex = phraseArray.length - 1;
                phraseArray.push({
                    ...phraseArray[workingIndex]
                }); // extend by copying the last -will only keep object structure
                workingIndex = phraseArray.length - 1;

                for (const tag in phraseArray[workingIndex]) {
                    if (Object.hasOwnProperty.call(phraseArray[workingIndex], tag)) {
                        // set all data inside empty
                        phraseArray[workingIndex][tag] = ""
                    }
                }
                
                // if (!Object.hasOwnProperty.call(phraseArray[workingIndex], 'chord')) {
                //phraseArray[workingIndex].chord = '*';
                phraseArray[workingIndex].number = 1;
                // }

                newData.lyrics.verses[verseId].lines[lineId].phrases = phraseArray
                app.song = newData;
                self.savableUpdate(true);
                //songCollection.db.setItem(songId, newData)
                song = newData;
                line = song.lyrics.verses[verseId].lines[lineId];
                self.clearSliders()
                self.$setState({
                    loading: false,
                    song: newData,
                    line: newData.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            savableUpdate: function(bool) {
                if (typeof(bool) != 'boolean'){
                    bool = false;
                }
                app.savable = bool;
                savable = bool;
                self.$setState({
                    savable: bool
                });
            },
            deletePhrase: function(e) {
                if( line.phrases.length <= 1 ){
                    return;
                }
                let newData = song;

                var workingIndex = (newData.lyrics.verses[verseId].lines[lineId].phrases).length - 1;
                let deletedPhrase = newData.lyrics.verses[verseId].lines[lineId].phrases.splice(workingIndex--, 1)[0]
                // merge the lyrics
                for (const tag in deletedPhrase) {
                    if (Object.hasOwnProperty.call(deletedPhrase, tag)) {
                        if (tag != 'chord' && tag != 'number'){
                            const element = deletedPhrase[tag];
                            newData.lyrics.verses[verseId].lines[lineId].phrases[workingIndex][tag] += element;
                        }
                    }
                }

                line = newData.lyrics.verses[verseId].lines[lineId]
                app.song = newData;
                self.savableUpdate(true)
                self.clearSliders()
                self.$setState({
                    loading: false,
                    song: newData,
                    line: newData.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            clearSliders: function() {
                languages.forEach(languageCode => {
                    var slider = self.$(`.slider-${languageCode}`)[0];
                    if (slider) {
                        if (slider.noUiSlider) {
                            slider.noUiSlider.destroy();
                        }
                    }
                });
            },
            displayLyricSliders: function(e) {
                // 
                var lyric = {};
                numberStartLocations = {}; //  {'en':[1,5,12]}
                //var noteList = [];           // tooltips: [ {to: function() {return "2<br/>A";} } ]
                var noteList = [];  
                line.numbers.forEach(element => {
                    noteList.push({
                        'to': function() {
                            return `${element}`
                        }
                    })
                });

                // init each language
                languages.forEach(languageCode => {
                    numberStartLocations[languageCode] = [];
                    lyric[languageCode] = [];
                });

                var firstPhrase = true;
                var lineModulated = lineModulate.consolidate(line)
                //
                for (const key in lineModulated) {
                    if (Object.hasOwnProperty.call(lineModulated, key)) {
                        // we're working with a single language here
                        // combining the whole line together (as if there were no chords)
                        // then splitting it back out as if the numbers were chords
                        const lang = lineModulated[key];
                        const element = lineModulated[key];
                        const languageLineCombinedLyric = lang.lyric;
                        const languageLineCombinedChordLocations = lang.chords;

                        // we need to split each of these in relation to position of 173
                        // use parseText
                        var parsed = parseText.remove(lang.lyric)
                        console.log(parsed)
                        // For Each then we need to find the true length of non diacritic elements

                        //let stringarr = ((typeof element == 'string') ? element.split("") : element[0].split(""));
                        //let stringarr = ( languageLineCombinedLyric.split( String.fromCharCode(173) ) );
                        let stringarr = parsed.splitLyrics
                        // 'aaa','bbb','ccccc'
                        if (!(stringarr.length == line.numbers.length || stringarr.length-1 == line.numbers.length)) {
                            console.error("What is happening, these should match")
                        }

                        let elementAsArray = lineModulate.diacriticChecker(parsed.lyric, 0) // lets work with the 'true' length array
                        lyric[key] = elementAsArray;

                        numberStartLocations[key] = parsed.numberStartLocations;
                        //var numberEndIndex;
                        // if (firstPhrase) {
                        //     numberStartLocations[key] = [];
                        //     numberEndIndex = 0;
                        // } else {
                        //     numberEndIndex = numberStartLocations[key].length;
                        // }

                        // if (number == -1 && firstPhrase) {// if first phrase skip it,
                        //     // if first, make a blank number area
                        //     numberStartLocations[key].push(elementAsArray.length);
                        // } else if (number == -1) { // else there is no number, concat with the last one  
                        //     // if there is no number, concat language array to last
                        //     numberStartLocations[key][numberEndIndex - 1] += elementAsArray.length;
                        // } else { // totally normal
                        //     // if this has a number, start adding number start locations
                        //     if (numberEndIndex == 0) {
                        //         numberStartLocations[key].push(elementAsArray.length);
                        //     } else {
                        //         numberStartLocations[key].push(numberStartLocations[key][numberEndIndex - 1] + elementAsArray.length);
                        //     }
                        // }
                    }
                }

                var pipFormatter = {}; //var pipFormats = {'0':'abc', '1':'pqr', '2':'xyz'};
                var range = {}; // {min/max/percentage: [increment, 1]}

                // setup pipFormatter
                // we want to group diacritic characters together
                for (const tag in lyric) {
                    pipFormatter[tag] = {};
                    range[tag] = {};
                    if (Object.hasOwnProperty.call(lyric, tag)) {
                        if (typeof(lyric[tag])) {
                            var langArray = lyric[tag]
                            let totalCharacters = langArray.length;
                            let increment = (Math.floor((100 / totalCharacters) * 10)) / 10
                            var i = 0;
                            // pipFormatter = {'min': [0,increment]}
                            range[tag]['min'] = [0, 1];
                            while (i < totalCharacters) {
                                // {('0':'abc')}
                                let currentChar = langArray[i]; // get char from position 0, insert to position 1
                                pipFormatter[tag][i.toString()] = currentChar;

                                // range
                                // {'50%': [1,1]}
                                let currentPlace = (increment * i) // starts at 0
                                let nextPlace = (increment * (++i))
                                range[tag][`${nextPlace}%`] = [i, 1];
                            };
                            pipFormatter[tag][i.toString()] = "";
                            range[tag]['max'] = [i, 1];
                            self.makeSlider(tag, pipFormatter[tag], range[tag], numberStartLocations[tag], noteList)
                        }
                    }
                };
            },
            makeSlider: function(tag, pipFormats, lyricRange, numberStartLocations, chordDataObject) {
                // if(numberStartLocations.length != chordDataObject.length){
                //     debugger
                //     numberStartLocations.pop()
                // } else { // is new data
                //     numberStartLocations.splice(0,0,'')
                //     numberStartLocations.pop()
                // }
                while(chordDataObject.length > numberStartLocations.length){
                    numberStartLocations.push(lyricRange.max[0])
                }
                var options = {}
                options.range = lyricRange;
                options.pips= {
                    mode: 'range',
                    format: {
                        to: function(a) {
                            return pipFormats[a];
                        }
                    }
                }
                if (chordDataObject.length){
                    options.tooltips = chordDataObject;
                    options.start= numberStartLocations;
                    options.tooltips= chordDataObject;
                } else {
                    // no chords on this song
                    options.start= [lyricRange.max[0]];
                }
                //  Make the slider
                var slider = self.$(`.slider-${tag}`)[0];  
                noUiSlider.create(slider, options);
                // noUiSlider.create(slider, {
                //     start: numberStartLocations,
                //     tooltips: chordDataObject,
                //     range: lyricRange,
                //     pips: {
                //         mode: 'range',
                //         format: {
                //             to: function(a) {
                //                 return pipFormats[a];
                //             }
                //         }
                //     }
                // });
            },
            lineEditPopup: function(tag) {
                // app.panel.create(parameters)
                // closeByBackdropClick
                // el	:HTMLElementstring

                // app.panel.open(panel, animate)
                // Other option. pass app.js the line data to pre-generate this generated popup when a button it programatically generates is pressed. 
                // onclick, it calls one of these to update. 
                // That's also the way to change lang on song edit
                
                var langLine = ""
                line.phrases.forEach(phrase => {
                    if (phrase[tag]) {
                        langLine += phrase[tag];
                    }
                });
  
                var el = `<div class="popup">
                        <div class="block">
                            <strong><h3>*edit line text here</h3></strong>
                            <div class='tag'>${tag}</div>
                            <form class="item-content item-input line-form" id="line-form">
                                <div class="item-inner">
                                    <div class="item-input-wrap" id="item-input-wrap">
                                    <input type="text" class="lineText" style=''value="${langLine}"/>
                                    <span class="input-clear-button"></span>
                                    </div>
                                </div>
                            </form>
                            <p><a  href="#" class="col popup-close button button-fill">*Preview</a></p>
                        </div>
                    </div>`
                var a = app.popup.create({
                    content:el,
                    'tag': tag,  
                    closeByBackdropClick: true,
                    on: {
                        opened: function (popup) {
                        console.log('Panel opened')
                        },
                        opened: function (popup) {
                            console.log('Popup opened');
                        },
                        close: function (popup) {
                            var tag = self.$$(".tag")[0].innerHTML
                            var formData = self.$$(".lineText")[0].value
                            self.updateLine(formData, tag)
                            self.savableUpdate(true)
                        },
                    }
                }); 
                a.open();
            },
            updateLine: function(data,tag){
                if (self.validateTag(tag)){
                    //update line and refresh
                    var lineArr = lineModulate.diacriticChecker(data.split(""), 0)
                    var chordPlacment = numberStartLocations[tag]

                    let i = 0
                    while (i < line.phrases.length) {
                        let firstChord = chordPlacment[i];
                        let startPhraseIndex = ((firstChord && firstChord < lineArr.length-1) ? firstChord : '0');
                        let nextChord = chordPlacment[i+1];
                        // checking that...
                        // the array may be shorter than we expect, allow phrases to be at end of array
                        // at end of array, include any extra characters
                        let endPhraseIndex = ((nextChord && nextChord < lineArr.length-1 && i < line.phrases.length) ? nextChord : (lineArr.length));

                        let phraseLength = endPhraseIndex - startPhraseIndex;
                        let newPhrase = lineArr.splice(0,phraseLength).join('');

                        //set it
                        line.phrases[i][tag] = newPhrase;
                        song.lyrics.verses[verseId].lines[lineId].phrases[i++][tag] = newPhrase;
                    }
                    self.clearSliders();
                    self.$setState({
                        loading: false,
                        song: song,
                        line: line
                    }, () => {
                        self.displayLyricSliders()
                        // User will need to save....
                    });                   
                }
            },
            validateTag: function(tag){
                if (languages.includes(tag)){
                    return true;
                }
                console.error("This should never fail")
                return false
            },
            backChecker: function(e){
                let newStatus = app.form.convertToData('#edit-donation')
                // Dirty is True if they don't match
                return (JSON.stringify(saveStatus) != JSON.stringify(newStatus))
                ev.preventDefault();
                // If status means form can be edited AND If form is dirty
                // then ask for confirmation 
                // complete 1581051573142 Submitted 1581051573215
                if (isDirty()) {
                    // 
                    var dialog = app.dialog.create({
                        backdrop: true,
                        closeByBackdropClick: false,
                        title: "<t>Leave this page?</t>",
                        text: "<t>Do you want to save your changes?</t>",
                        buttons: [{
                                text: "<t>Don't Save</t>",
                                onClick: (dialog, ev) => {
                                    this.$router.back();
                                }
                            },
                            {
                                text: "<t>Save</t>",
                                onClick: (dialog, ev) => {
                                    app.dialog.close()
                                    setStatus()
                                }
                            }
                        ],
                        verticalButtons: true
                    });
                    dialog.open();
                }
                // If form is empty, go back immediately
                else {
                    this.$router.back();
                }
            }
        }
    }
</script>