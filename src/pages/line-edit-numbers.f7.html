<template>
    <div class="page">
        <div class="navbar">
            <div class="navbar-bg"></div>
            <div class="navbar-inner sliding">
                <div class="left">
                    <a {{#if loading}}href=""{{else}}href="/song/view/{{this.songId}}/"{{/if}} class="link back" data-force="true" data-ignore-cache="true">
                        <i class="icon icon-back"></i> 
                        <span class="if-not-md" >{{#if loading}}Back{{else}}{{translate "Back"}}{{/if}}</span>
                    </a>
                </div>
                <div class="title">{{#if loading}}{{else}} {{song.title[defaultLanguage]}} : {{@root.verseLabel}} {{/if}}</div>
            </div>
        </div>
        <div class="page-content hide-navbar-on-scroll">
            {{#js_if "!@root.loading"}}
                <div class="block block-strong" style="margin-bottom: 10px; overflow: hidden;">
                    <div class="menu">
                        <div class="menu-inner no-margin-padding">
                            <!-- Stepper element -->
                            <div class="stepper stepper-large stepper-fill" style="display: none; margin-left: auto; height: 40px;">
                                <div class="stepper-button-minus"></div>
                                <div class="stepper-input-wrap">
                                    <input type="text" value="{{transpose song.key @root.steps}}" readonly>
                                </div>
                                <div class="stepper-button-plus"></div>
                            </div>
                            <div>
                                <div class="menu-item">
                                    <div class="menu-item-content icon-only">
                                        <div class="menu-item-content">
                                            <a @click="save" class="col button button-fill">
                                                <i class="text-color-gray fa-bigger fas fa-save"></i>
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a class="col button button-fill{{#if firstLine}} disabled{{/if}}" @click="prevLine">
                                            <i class="text-color-gray fas fa-bigger fa-arrow-left"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                            goto next
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="nextLine" class="col button button-fill{{#js_if "@root.lastLine && @root.lastVerse"}} disabled{{/js_if}}">
                                            <i class="text-color-gray fa-bigger fas fa-arrow-right"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="item-title item-label">
                                Number tools:
                            </div>
                            <!--
                                phrase
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="addPhrase" class="col button">
                                            <i class="text-color-gray fas fa-plus"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                                delete phrase, only show if totally empty??????
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="deletePhrase" class="col button">
                                            <i class="text-color-gray fas fa-trash"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                            LINE
                            -->
                            <!-- <div class="item-title item-label">
                                <t>Line tools:</t>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="addLine" class="col button button-fill">
                                            <i class="text-color-gray fa-bigger fas fa-plus"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a class="col button button-fill" @click="deleteLine">
                                            <i class="text-color-gray fa-bigger fas fa-trash"></i>
                                        </a>
                                    </div>
                                </div>
                            </div> -->
                        </div>
                    </div>

                    <div class="sheet">
                        <div class="song">
                            <div class="verse">
                                <div class="line" id="edit-line">
                                    <!-- -->
                                    {{ printEachNumber @root.line }}
                                    <!-- -->
                                    {{ printLyric @root.line}}
                                </div>
                            </div>
                        </div>
                    </div>
                {{#js_if "@root.savable"}}
                    <p><a @click="save"  class="col popup-close button button-fill">*Save</a></p>
                {{/js_if}}
                </div>
                <div class="block text-align-right text-color-gray" style="margin-top: 10px;">
                    {{song.author[defaultLanguage]}}
                </div>
            {{/js_if}}
        </div>
    </div>
</template>
<style>
    .noUi-marker {
        height: 0 !important;
    }

    .no-margin-padding {
        margin: 0;
        padding: 0;
    }

    .fa-bigger {
        font-size: larger;
    }

    .song {
        transform-origin: left top;
    }

    .line {
        margin-bottom: 20px;
    }

    .phrase {
        position: relative;
        display: inline-block;
        margin: 55px 10px 0 0;
        min-width: 20px;
    }

    .chord,
    .number {
        top: -55px;
        background: var(--f7-theme-color);
        border-radius: 3px;
        min-width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        color: white;
        font-weight: bold;
        display: inline-block;
        padding: 0 2px;
        margin-right: 5px;
        position: absolute;
        padding: 2px;
    }

    .number {
        top: -25px;
        border-radius: 100%;
        width: 20px;
        height: 20px;
        padding: 2px;
        background: var(--f7-color-blue);
        font-family: 'Notes', monospace;
    }

    .noNumbers,
    .noChords {
        margin-top: 30px !important;
    }

    .noNumbers.noChords {
        margin-top: 10px !important;
    }

    .noNumbers .chord,
    .noChords .chord {
        top: -30px;
    }
</style>
<script>
    var songId
    var loading
    var savable = false;
    var verseId
    var verseLabel
    var lineId
    var languages
    var lyricList
    var line
    var song
    var app
    var lastVerse
    var lastLine
    var firstLine
    var numberStartLocations
    import DataManager from '../data/dataManager';
    import Song from '../data/song';
    import noUiSlider from 'nouislider';
    import 'nouislider/dist/nouislider.css';
    // //  the namespace:
    // import * as noUiSlider from 'nouislider';
    // import 'nouislider/dist/nouislider.css';

    // // Alternatively, you can include both files:
    // <link href="nouislider.css" rel="stylesheet">
    // <script src="nouislider.js"><//////script>

    import Preference from "../data/preference";
    const dataManager = new DataManager();
    const songCollection = new Song();
    const preference = new Preference();

    // Import locales
    const locale = require('../js/locales.js');

    var initScale = 1;
    var lyric1;
    var lyric2;
    var defaultLanguage;
    var deviceWidth = window.innerWidth;
    var self = this;
    if (deviceWidth >= 700) {
        initScale = 2;
    } else if (deviceWidth >= 500) {
        initScale = 1.5;
    }
    var steps = 0;

    export default {
        // Component Data
        data: function() {
            // Must return an object
            self = this;
            return {
                loading: true,
                savable: savable,
                lastVerse: false,
                lastLine: false,
                firstLine: false,
                showNumber: false,
                showChord: false
            }
        },
        // Page Events
        on: {
            pageInit: function(e, page) {
                self = this;
                app = self.$app;
                var $form = this.$('#edit-line')
                
                songId = this.$route.params.songId;
                verseId = this.$route.params.verseId;
                lineId = this.$route.params.lineId;
                
                // get global savable
                self.savableUpdate(app.savable);

                preference.getLanguage().then((languageCode) => {
                    lyric1 = languageCode;
                    defaultLanguage = languageCode;
                    languages = [];
                    lyricList = []
                    var result = app.song;
                    var translationLangs = Object.keys(result.lyrics.verses[verseId].lines[lineId].phrases[0]);
                    //var translationLangs = Object.keys(result.title);
                    locale.customLocales.forEach((item) => {
                        if (translationLangs.indexOf(item.tag) > -1) {
                            if (item.tag == lyric1) {
                                item.default = true;
                            }
                            languages.push(item.tag)
                        }
                    });
                    line = result.lyrics.verses[verseId].lines[lineId]

                    // check if last line
                    lastLine = (lineId >= (result.lyrics.verses[verseId].lines.length - 1));
                    lastVerse = (verseId >= (result.lyrics.verses.length - 1));
                    // song is used to get next line
                    song = result

                    self.$setState({
                        loading: false,
                        savable: savable,
                        songId: songId,
                        lastLine: lastLine,
                        lastVerse: lastVerse,
                        verseLabel: result.lyrics.verses[verseId].label,
                        firstLine: (lineId == 0 && verseId == 0),
                        song: song,
                        // verse: result.verse[verseId],
                        line: line,
                        steps: steps,
                        languages: languages,
                        lyricList: lyricList,
                        defaultLanguage: defaultLanguage
                    }, () => {
                        self.$(".song")[0].style.transform = "scale(" + initScale + ")";
                        self.$(".sheet")[0].style.height = (self.$(".song")[0].offsetHeight * initScale) + "px";

                        // make the sliders
                        self.displayLyricSliders()

                        languages.forEach(lang => {
                            line.phrases.forEach(phrase => {
                                lyricList.push({
                                    "tag": lang,
                                    "lyric": line[lang]
                                })
                            });
                        });

                        var stepper = app.stepper.create({
                            el: '.stepper',
                            value: steps,
                            min: 0,
                            max: 11,
                            wraps: true,
                            on: {
                                change: function(e) {
                                    steps = e.value;
                                    self.$setState({
                                        steps: steps,
                                    });
                                }
                            }
                        });
                    });
                });
            },
        },
        methods: {
            zoomIn: function(e) {
                initScale += 0.05;
                this.$(".song")[0].style.transform = "scale(" + initScale + ")";
                this.$(".sheet")[0].style.height = (this.$(".song")[0].offsetHeight * initScale) + "px";
            },
            zoomOut: function(e) {
                initScale -= 0.05;
                this.$(".song")[0].style.transform = "scale(" + initScale + ")";
                this.$(".sheet")[0].style.height = (this.$(".song")[0].offsetHeight * initScale) + "px";
            },
            save: function(e) {
                var $form = this.$('#edit-line')
                var $ = $form.find("select[name='']") //relation
                if (!self.$app.input.validateInputs('#edit-line')) {
                    // TODO make this say what the error is
                    self.$app.dialog.alert('Please correct your entries.');
                    console.error('<t>Please correct your entries.</t>');
                } else {
                    let newData = song;                   
                    var newLineCombined = [];
                    languages.forEach(langTag => { // selected language
                        newLineCombined = self.combineLines(newLineCombined, self.parseLanguageText(langTag));
                    });                    
                    
                    // fill in the numbers, we left empty slots earlier
                    var metaIndex = 0;
                    var phraseIndex = 0;
                    
                    while (phraseIndex < newLineCombined.length) {
                        if(typeof(newLineCombined[phraseIndex].number) !== 'undefined' ){
                            let id = ('.number').concat(metaIndex)
                            let number = self.$(id)[0]//.value // self.$('.number1').firstElementChild.value
                            if (number) { // our template will not create form if it's supposed to be blank
                            // setting number
                            let number = self.$(id)[0].value 
                                newLineCombined[phraseIndex].number = number
                            }
                            metaIndex ++;
                        }
                        phraseIndex++;
                    }; 

                    newData.lyrics.verses[verseId].lines[lineId] = newLineCombined;
                    // // this only updates the numbers, **if the nouisliders were not modified** this would be a fast way of updating just the notes
                    // var metaIndex = 0;
                    // var phraseIndex = 0;

                    // while (phraseIndex < newData.lyrics.verses[verseId].lines[lineId].phrases.length) {
                    //     if(newData.lyrics.verses[verseId].lines[lineId].phrases[phraseIndex].number){
                    //         let id = ('.number').concat(metaIndex)
                    //         let number = self.$(id)[0]//.value // self.$('.number1').firstElementChild.value
                    //         if (number) { // our template will not create form if it's supposed to be blank
                    //             // setting number
                    //             let number = self.$(id)[0].value 
                    //             newData.lyrics.verses[verseId].lines[lineId].phrases[phraseIndex]['number'] = number
                    //         }
                    //         metaIndex ++;
                    //     }
                    //     phraseIndex++;
                    // };
                    
                    // save
                    line = newLineCombined;
                    song = newData;
                    app.song = newData;
                    //songCollection.db.setItem(songId, newData);
                    self.savableUpdate(false);
                    self.clearSliders();
                    self.$setState({
                        loading: false,
                        song: newData,
                        line: newData.lyrics.verses[verseId].lines[lineId]
                    }, () => {
                        self.displayLyricSliders();
                    });
                    // send line changes to server
                    // dataManager.putLine(songId, verseId, lineId, newData.lyrics.verses[verseId].lines[lineId])
                    //     .then(responseText => alert(JSON.stringify(responseText)));
                    // send whole song to server
                    // dataManager.putSong(songId, newData)
                    //  .then(responseText => alert(JSON.stringify(responseText)));
                
                }
            },
            parseLanguageText: function(tag, languageLine, insertArray){
                // I need the full string "Twinkle, twinkle, little star"
                // I need placment of phrase breaks ["0.00", "10.00", "15.00"]
                // return [('Twinkle, tw'),('inkle'),(', little star')]
                var chordMap = []
                if(!insertArray){ // get from dom
                    try {
                        insertArray = this.$$(`#slider-${tag}`)[0].noUiSlider.get()
                    } catch (error) {
                        console.error(error)
                    }
                    if (!insertArray) {
                        console.error({"no div for tag":tag})
                    }
                }
                if(!languageLine){ // get from global var
                    try {
                        languageLine = ''
                        var languageLen = 0
                        var languageArr = []
                        var lastLength = 0
                        var first = true;
                        line.phrases.forEach(phrase => {
                            if (Object.hasOwnProperty.call(phrase, tag)) {
                                languageLine = languageLine.concat(phrase[tag]); 
                                let arr = self.diacriticChecker(phrase[tag], 0);
                                languageArr = languageArr.concat(arr)
                                languageLen += arr.length
                            } 
                            let phraseMap = {}
                            if (Object.hasOwnProperty.call(phrase, 'chord')) { // has chord
                                phraseMap['len'] = lastLength // we get distance from start
                                lastLength = languageLen
                                phraseMap['chord'] = phrase['chord']
                                chordMap.push(phraseMap)
                            } else if (!Object.hasOwnProperty.call(phrase, 'number') && !Object.hasOwnProperty.call(phrase, 'chord') && first ) { 
                                // first phrase is chordless,
                                phraseMap['len'] = 0 // is start
                                lastLength =  languageLen
                                phraseMap['chord'] = ''
                                chordMap.push(phraseMap)
                            }

                            first = false;
                        });
                    } catch (error) {
                        console.error(error)
                    }
                    if (!languageLine) {
                        console.error({"no line data for tag":tag});
                    }
                }
                var phraseArray = [] ;// ["Twin","kle, twinkle,", " little star"]
                
                if (typeof insertArray === 'string'){// there's only the one chord
                    if (parseInt(insertArray) != 0){ // we need two phrases
                        var parsedLineArr = self.diacriticChecker(languageLine.split(""), 0);
                        phraseArray.push( (parsedLineArr.splice(0, parseInt(insertArray) )).join("") ); 
                        phraseArray.push( parsedLineArr.join("") ); // remaining
                    } else {
                        phraseArray.push(languageLine);
                    }
                } else {
                    if( typeof languageLine == 'string'){
                        languageLine = languageLine.split("");
                    }
                    var parsedLineArr =  self.diacriticChecker(languageLine, 0);
                    var lastPhraseLength = 0;
                    var firstChord = true;
                    var totalPhrases = insertArray.length

                    var i = 0;
                    // insertIndex = 0;
                    // chordMap
                    console.log(chordMap) // this is the expected map
                    console.log(languageArr) // this is the expected map
                    // chordMap.length != insertArray.length 
                    // [cL,cL]
                    // [L0,cL3, cL5] (starts at)
                    // insert: nums at 0,3,6
                    // [Ln0,cLn3,cL5,Ln6]
                    // ["Twin","kle, twinkle,", " little star"]
                    // ["Twin","kle, twinkle,", " little star"]

                    // from JSON
                    // chordMap
                    // from nouislider
                    // insertArray
                    if (chordMap){
                        var chordMapi = 0
                        var insertArrayi = 0
                        var latestIndex = -1
                        var lastPhrase = false
                        var lastLanguageLetter = parsedLineArr.length

                        var newPhraseLayout = []
                        var first = true;

                        while(chordMap[chordMapi] || insertArray[insertArrayi] ){ 

                            // right now we know where both chords and numbers want to be
                            // we have an array of language characters
                            // SHOULD we just make the phrase here and now?
                            var newIndex = parseInt(insertArray[insertArrayi]);
                            if (insertArray[insertArrayi] === undefined){
                                newIndex = chordMap[chordMap.length-1].len + 1 // one greater than largest chord map
                            }
                            
                            var mapIndex 
                            if (chordMap[chordMapi] != undefined){
                                mapIndex = chordMap[chordMapi].len;
                            } else {
                                mapIndex = newIndex + 1 // one greater
                            }

                            var currentTargetIndex = ( (newIndex >= mapIndex) ? newIndex : mapIndex );

                            let elem = {};
                            if (first && (chordMap[0]['chord'] === '' || newIndex != 0 )) {
                                // phrase 0 can lack a chord/num
                                if ( (chordMap[0]['chord'] === '')) {
                                    // a different language has a meta-less phrase: insert a blank
                                    elem[tag] = ('');
                                    //latestIndex = 0;
                                    chordMapi++
                                }

                                //New first numberless phrase
                                if(newIndex != 0 ){
                                    elem[tag] = parsedLineArr.splice(0,newIndex).join('');
                                    latestIndex = chordMap[0].len;
                                    // do not iterate!
                                } 
                                first = false;
                                
                            } else {

                                let catchRepeatedIndex = ( latestIndex == currentTargetIndex )
                                if (catchRepeatedIndex){
                                    // don't push language
                                    // [1,2,3,4,4!,4,4,4,4,4]
                                    //        |<-----------
                                    // [1,!1,1,1,1,2,3,4]
                                    //   ------->|
                                    let onLastLetter = ( lastLanguageLetter <= currentTargetIndex)
                                    if(onLastLetter){ // 4 <= 4
                                        // both of these have reached end of line
                                        if ( chordMap[chordMapi] ) {
                                            elem['chord'] = chordMap[chordMapi].chord
                                            chordMapi++
                                        }
                                        if( insertArray[insertArrayi] ){
                                            latestIndex = chordMap[0].len;
                                            elem['number'] = ''
                                            insertArrayi++
                                        } 
                                    } else {
                                        // there is no 'room' for language 
                                        // remove from last phrase, move up

                                        //this starts being wrong after second splice
                                        elem[tag] = new String(newPhraseLayout[newPhraseLayout.length-1][tag]) // {chord: number: en:}  
                                        newPhraseLayout[newPhraseLayout.length-1][tag] = ''
                                    } 
                                    // note: leading phrases will have empty attrubute, trailing will lack attrib. after first
                                } else {
                                    // insert language normally
                                    // start at 0, 
                                    // remove currentTargetIndex - latestIndex, 
                                    elem[tag] = parsedLineArr.splice(0,currentTargetIndex-latestIndex).join('')
                                }

                                // every phrase (aside from 0) must have either/both chord or num
                                if ( mapIndex == (newIndex) ){ // 1 == 1
                                    // both: c and num on same character 
                                    elem['chord'] = chordMap[chordMapi].chord
                                    elem['number'] = ''
                                    latestIndex = newIndex
                                    insertArrayi++
                                    chordMapi++ 
                                } else if ( mapIndex > (newIndex) ){ // 3 > 2
                                    // num first 
                                    elem['number'] = ''
                                    latestIndex = newIndex
                                    insertArrayi++
                                } else if  ( mapIndex < (newIndex) ){ // 3 < 5
                                    // chord first
                                    elem['chord'] = chordMap[chordMapi].chord
                                    latestIndex = mapIndex
                                    chordMapi++
                                } else {
                                    insertArrayi++
                                    chordMapi++
                                    console.error("Both chordmap and insertarray are invalid")
                                    //debugger
                                    // at end
                                }
                            } 
                            // always push a phrase
                            newPhraseLayout.push(elem)
                        }     
                        //console.log(newPhraseLayout);
                        phraseArray = newPhraseLayout;
                    } else {
                        while (newIndex) {// while (chordMap[i]) {
                            let chord = (newIndex); // let chord = (insertArray[insertIndex]);
                            // let Map = (insertArray[insertIndex]);
                            var currentIndexValue = parseInt(chord);
                            var currentPhraseLength
                            // to chop off index
                            
                            
                            if(firstChord && currentIndexValue != 0){ // first and skipping phrase
                                firstChord = false;
                                // put a chordless phrase end of chordless is start of next
                                let toInsert = (parsedLineArr.splice(0,currentIndexValue)).join(""); // splice(start, deleteCount)
                                totalPhrases++;
                                phraseArray.push( toInsert );
                            } else {
                                firstChord = false;
                            }
                                
                                //else if(firstChord && currentIndexValue === 0){ // There is always a chordless phrase
                            //     phraseArray.push( '' )
                            // }
                            if (totalPhrases == phraseArray.length+1){ // we're on last chord, claim rest of phrase
                                currentPhraseLength = parsedLineArr.length;
                                i++;
                            } else { // middle
                                currentPhraseLength = parseInt(insertArray[i+1]) - currentIndexValue;
                                i++;
                            }
                            
                            
                            lastPhraseLength = currentPhraseLength;
                            let toInsert = (parsedLineArr.splice(0,currentPhraseLength)).join(""); // splice(start, deleteCount)
                            phraseArray.push( toInsert );
                        }
                    }
                }
                console.log({'new line': phraseArray});
                return phraseArray;
            },
            combineLines: function(oldLine, newLine) {
                // [{en:''},{number:1, chord:'A', en:'Hey Jude'}]
                // [{es:''},{number:1, chord:'A', es:'Hola Jude'}]
                // [{number:1, chord:'A', ja:'Moshi Jude'}]
                // [{th:'Saw'},{number:1, chord:'A', th:'-adee Jude'}]
                // result = [{en:'',es:'',ja:'',th:'Saw'},{number:1, chord:'A', en:'Hey Jude', es:'Hola Jude',ja:'Moshi Jude', th:'-adee Jude'}]

                if (oldLine.length !== newLine.length){
                    if (oldLine.length === 0){
                        return newLine
                    } else {
                        console.error('these should be the same?');
                        //debugger
                    }
                }
                var i = 0;
                var newLineArr = [];
                while(newLine[i]){
                    let newPhrase;
                    if (i==0){
                        let oldIsMetaless =  ( !Object.hasOwnProperty.call(oldLine[i], 'number') && !Object.hasOwnProperty.call(oldLine[i], 'chord') );
                        let newIsMetaless = ( !Object.hasOwnProperty.call(newLine[i], 'number') && !Object.hasOwnProperty.call(newLine[i], 'chord') );
                        if (oldIsMetaless && newIsMetaless){
                            // they match already
                            newPhrase = {
                                ...oldLine[i],
                                ...newLine[i]
                            };
                        } else if (oldIsMetaless){
                            newPhrase = newLine[i];
                            for (const key in oldLine[i]) {
                                if (Object.hasOwnProperty.call(oldLine[i], key) && key != 'chord' && key != 'number') {
                                    const element = oldLine[i][key];
                                    // only insert a blank, data will be coped in next iteration
                                    newPhrase[key] = ''
                                }
                            }
                            // splice(start, deleteCount, item1)
                            // push the index up so it's used in next iteration
                            oldLine.splice(0,0,newPhrase)
                        } else if (newIsMetaless){
                            // same as this ^^
                            newPhrase = oldLine[i];
                            for (const key in newLine[i]) {
                                if (Object.hasOwnProperty.call(newLine[i], key) && key != 'chord' && key != 'number') {
                                    const element = newLine[i][key];
                                    newPhrase[key] = ''
                                }
                            }
                            newLine.splice(0,0,newPhrase)
                        }
                    } else {
                        newPhrase = {
                            ...oldLine[i],
                            ...newLine[i]
                        };
                    }
                    newLineArr.push(newPhrase);
                    i++;
                }
                return newLineArr
            },
            nextLine: function(e) {
                // only get index forward if it exists in song
                if (lastLine && !lastVerse) { // if at end of NOTlastVerse, check next verse
                    lastVerse = ((verseId + 1) >= (song.lyrics.verses.length - 1)); // is next verse last verse?
                    lastLine = ((song.lyrics.verses[parseInt(verseId) + 1].lines[1]) == undefined); // is there only one line in next verse?
                    ++verseId;
                    lineId = 0;
                    verseLabel = song.lyrics.verses[verseId].label;
                } else {
                    // check if last line
                    lastLine = ((lineId + 1) >= (song.lyrics.verses[verseId].lines.length - 1));
                    ++lineId;
                }
                // update variable
                line = song.lyrics.verses[verseId].lines[lineId]
                self.clearSliders()
                self.$setState({
                    loading: false,
                    firstLine: (lineId == 0 && verseId == 0),
                    lastLine: lastLine,
                    lastVerse: lastVerse,
                    verseLabel: verseLabel,
                    line: song.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.clearSliders()
                    self.displayLyricSliders()
                });
            },
            prevLine: function(e) {
                if (lineId == 0) {
                    --verseId
                    lineId = song.lyrics.verses[verseId].lines.length - 1
                    // update variable
                    lastVerse = ((verseId) >= (song.lyrics.verses.length - 1)); // is next verse last verse?
                    verseLabel = song.lyrics.verses[verseId].label;
                } else {
                    --lineId
                }
                line = song.lyrics.verses[verseId].lines[lineId]
                self.clearSliders()
                self.$setState({
                    loading: false,
                    firstLine: (lineId == 0 && verseId == 0),
                    lastLine: false,
                    verseLabel: verseLabel,
                    lastVerse: lastVerse,
                    line: song.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            addPhrase: function(e) {
                let newData = song
                // At index, add one element

                var phraseArray = newData.lyrics.verses[verseId].lines[lineId].phrases
                var workingIndex = phraseArray.length - 1;
                phraseArray.push({
                    ...phraseArray[workingIndex]
                }); // extend by copying the last -will only keep object structure
                workingIndex = phraseArray.length - 1;

                for (const tag in phraseArray[workingIndex]) {
                    if (Object.hasOwnProperty.call(phraseArray[workingIndex], tag)) {
                        // set all data inside empty
                        phraseArray[workingIndex][tag] = ""
                    }
                }
                
                // if (!Object.hasOwnProperty.call(phraseArray[workingIndex], 'chord')) {
                //phraseArray[workingIndex].chord = '*';
                phraseArray[workingIndex].number = 1;
                // }

                newData.lyrics.verses[verseId].lines[lineId].phrases = phraseArray
                app.song = newData;
                self.savableUpdate(true);
                //songCollection.db.setItem(songId, newData)
                song = newData;
                line = song.lyrics.verses[verseId].lines[lineId];
                self.clearSliders()
                self.$setState({
                    loading: false,
                    song: newData,
                    line: newData.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            savableUpdate: function(bool) {
                if (typeof(bool) != 'boolean'){
                    bool = false;
                }
                app.savable = bool;
                savable = bool;
                self.$setState({
                    savable: bool
                });
            },
            deletePhrase: function(e) {
                if( line.phrases.length <= 1 ){
                    return;
                }
                let newData = song;

                var workingIndex = (newData.lyrics.verses[verseId].lines[lineId].phrases).length - 1;
                let deletedPhrase = newData.lyrics.verses[verseId].lines[lineId].phrases.splice(workingIndex--, 1)[0]
                // merge the lyrics
                for (const tag in deletedPhrase) {
                    if (Object.hasOwnProperty.call(deletedPhrase, tag)) {
                        if (tag != 'chord' && tag != 'number'){
                            const element = deletedPhrase[tag];
                            newData.lyrics.verses[verseId].lines[lineId].phrases[workingIndex][tag] += element;
                        }
                    }
                }

                line = newData.lyrics.verses[verseId].lines[lineId]
                app.song = newData;
                self.savableUpdate(true)
                self.clearSliders()
                self.$setState({
                    loading: false,
                    song: newData,
                    line: newData.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            clearSliders: function() {
                languages.forEach(languageCode => {
                    var slider = self.$(`.slider-${languageCode}`)[0];
                    if (slider) {
                        if (slider.noUiSlider) {
                            slider.noUiSlider.destroy();
                        }
                    }
                });
            },
            displayLyricSliders: function(e) {
                // 
                var lyric = {};
                numberStartLocations = {}; //  {'en':[1,5,12]}
                var chordList = [];           // tooltips: [ {to: function() {return "2<br/>A";} } ]

                // init each language
                languages.forEach(languageCode => {
                    numberStartLocations[languageCode] = [];
                    lyric[languageCode] = [];
                });

                var firstPhrase = true;
                line.phrases.forEach(phrase => {
                    let meta = {}; // chord and number
                    if (phrase['number']) {
                        meta.number = phrase['number']
                        // push to num list
                        chordList.push({
                            'to': function() {
                                return `${meta.number}`
                            }
                        })
                    }
                    for (const key in phrase) {
                        if (Object.hasOwnProperty.call(phrase, key) && key != 'chord' && key != 'number') {
                            const element = phrase[key];
                            let stringarr = ((typeof element == 'string') ? element.split("") : element[0].split(""));
                            let elementAsArray = self.diacriticChecker(stringarr, 0) // lets work with the 'true' length array
                            if(lyric[key]){
                                lyric[key] = lyric[key].concat(elementAsArray);
                            } else{
                                lyric[key] = elementAsArray;
                            }
                            var numberEndIndex;
                            if (firstPhrase) {
                                numberStartLocations[key] = [];
                                numberEndIndex = 0;
                            } else {
                                numberEndIndex = numberStartLocations[key].length;
                            }

                            if (!meta.number && firstPhrase) {// if first phrase skip it,
                                // if first, make a blank number area
                                numberStartLocations[key].push(elementAsArray.length);
                            } else if (!meta.number) { // else there is no number, concat with the last one  
                                // if there is no number, concat language array to last
                                numberStartLocations[key][numberEndIndex - 1] += elementAsArray.length;
                            } else { // totally normal
                                // if this has a number, start adding number start locations
                                if (numberEndIndex == 0) {
                                    numberStartLocations[key].push(elementAsArray.length);
                                } else {
                                    numberStartLocations[key].push(numberStartLocations[key][numberEndIndex - 1] + elementAsArray.length);
                                }
                            }
                        }
                    }
                    firstPhrase = false;
                });
                //console.log(numberStartLocations)

                var pipFormatter = {}; //var pipFormats = {'0':'abc', '1':'pqr', '2':'xyz'};
                var range = {}; // {min/max/percentage: [increment, 1]}

                for (const tag in lyric) {
                    pipFormatter[tag] = {};
                    range[tag] = {};
                    if (Object.hasOwnProperty.call(lyric, tag)) {
                        if (typeof(lyric[tag])) {
                            var langArray = lyric[tag]
                            let totalCharacters = langArray.length;
                            let increment = (Math.floor((100 / totalCharacters) * 10)) / 10
                            var i = 0;
                            // pipFormatter = {'min': [0,increment]}
                            range[tag]['min'] = [0, 1];
                            while (i < totalCharacters) {
                                // {('0':'abc')}
                                let currentChar = langArray[i]; // get char from position 0, insert to position 1
                                pipFormatter[tag][i.toString()] = currentChar;

                                // range
                                // {'50%': [1,1]}
                                let currentPlace = (increment * i) // starts at 0
                                let nextPlace = (increment * (++i))
                                range[tag][`${nextPlace}%`] = [i, 1];
                            };
                            pipFormatter[tag][i.toString()] = "";
                            range[tag]['max'] = [i, 1];
                            self.makeSlider(tag, pipFormatter[tag], range[tag], numberStartLocations[tag], chordList)
                        }
                    }
                };
            },
            makeSlider: function(tag, pipFormats, lyricRange, numberStartLocations, chordDataObject) {
                if(numberStartLocations.length != chordDataObject.length){
                    numberStartLocations.pop()
                } else { // is new data
                    numberStartLocations.splice(0,0,'')
                    numberStartLocations.pop()
                }
                while(chordDataObject.length > numberStartLocations.length){
                    numberStartLocations.push(lyricRange.max[0])
                }
                var options = {}
                options.range = lyricRange;
                options.pips= {
                    mode: 'range',
                    format: {
                        to: function(a) {
                            return pipFormats[a];
                        }
                    }
                }
                if (chordDataObject.length){
                    options.tooltips = chordDataObject;
                    options.start= numberStartLocations;
                    options.tooltips= chordDataObject;
                } else {
                    // no chords on this song
                    options.start= [lyricRange.max[0]];
                }
                //  Make the slider
                var slider = self.$(`.slider-${tag}`)[0];  
                noUiSlider.create(slider, options);
                // noUiSlider.create(slider, {
                //     start: numberStartLocations,
                //     tooltips: chordDataObject,
                //     range: lyricRange,
                //     pips: {
                //         mode: 'range',
                //         format: {
                //             to: function(a) {
                //                 return pipFormats[a];
                //             }
                //         }
                //     }
                // });
            },
            // Params: Array, 0
            diacriticChecker: function(array, index) {
                if (!index) {index = 0};
                if (typeof(array)=='string') {
                    array = array.split("");
                }
                var nextIndex = index + 1
                if (nextIndex >= array.length) {
                    return array;
                }
                //if ([' ྱ', ' ེ', ' ོ', ].includes(array[nextIndex])){
                if ([4017, 3962, 3964, 3954].includes((array[nextIndex]).charCodeAt(0))) {
                    array[index] = array[index].concat(array.splice(nextIndex, 1)[0]);
                } else { // only increase if no diacritic
                    ++index;
                }
                return self.diacriticChecker(array, index);
            },
            lineEditPopup: function(tag) {
                // app.panel.create(parameters)
                // closeByBackdropClick
                // el	:HTMLElementstring

                // app.panel.open(panel, animate)
                // Other option. pass app.js the line data to pre-generate this generated popup when a button it programatically generates is pressed. 
                // onclick, it calls one of these to update. 
                // That's also the way to change lang on song edit
                
                var langLine = ""
                line.phrases.forEach(phrase => {
                    if (phrase[tag]) {
                        langLine += phrase[tag];
                    }
                });
  
                var el = `<div class="popup">
                        <div class="block">
                            <strong><h3>*edit line text here</h3></strong>
                            <div class='tag'>${tag}</div>
                            <form class="item-content item-input line-form" id="line-form">
                                <div class="item-inner">
                                    <div class="item-input-wrap" id="item-input-wrap">
                                    <input type="text" class="lineText" style=''value="${langLine}"/>
                                    <span class="input-clear-button"></span>
                                    </div>
                                </div>
                            </form>
                            <p><a  href="#" class="col popup-close button button-fill">*Preview</a></p>
                        </div>
                    </div>`
                var a = app.popup.create({
                    content:el,
                    'tag': tag,  
                    closeByBackdropClick: true,
                    on: {
                        opened: function (popup) {
                        console.log('Panel opened')
                        },
                        opened: function (popup) {
                            console.log('Popup opened');
                        },
                        close: function (popup) {
                            var tag = self.$$(".tag")[0].innerHTML
                            var formData = self.$$(".lineText")[0].value
                            self.updateLine(formData, tag)
                            self.savableUpdate(true)
                        },
                    }
                }); 
                a.open();
            },
            updateLine: function(data,tag){
                if (self.validateTag(tag)){
                    //update line and refresh
                    var lineArr = self.diacriticChecker(data.split(""), 0)
                    var chordPlacment = numberStartLocations[tag]

                    let i = 0
                    while (i < line.phrases.length) {
                        let firstChord = chordPlacment[i];
                        let startPhraseIndex = ((firstChord && firstChord < lineArr.length-1) ? firstChord : '0');
                        let nextChord = chordPlacment[i+1];
                        // checking that...
                        // the array may be shorter than we expect, allow phrases to be at end of array
                        // at end of array, include any extra characters
                        let endPhraseIndex = ((nextChord && nextChord < lineArr.length-1 && i < line.phrases.length) ? nextChord : (lineArr.length));

                        let phraseLength = endPhraseIndex - startPhraseIndex;
                        let newPhrase = lineArr.splice(0,phraseLength).join('');

                        //set it
                        line.phrases[i][tag] = newPhrase;
                        song.lyrics.verses[verseId].lines[lineId].phrases[i++][tag] = newPhrase;
                    }
                    self.clearSliders();
                    self.$setState({
                        loading: false,
                        song: song,
                        line: line
                    }, () => {
                        self.displayLyricSliders()
                        // User will need to save....
                    });                   
                }
            },
            validateTag: function(tag){
                if (languages.includes(tag)){
                    return true;
                }
                console.error("This should never fail")
                return false
            },
            backChecker: function(e){
                let newStatus = app.form.convertToData('#edit-donation')
                // Dirty is True if they don't match
                return (JSON.stringify(saveStatus) != JSON.stringify(newStatus))
                ev.preventDefault();
                // If status means form can be edited AND If form is dirty
                // then ask for confirmation 
                // complete 1581051573142 Submitted 1581051573215
                if (isDirty()) {
                    // 
                    var dialog = app.dialog.create({
                        backdrop: true,
                        closeByBackdropClick: false,
                        title: "<t>Leave this page?</t>",
                        text: "<t>Do you want to save your changes?</t>",
                        buttons: [{
                                text: "<t>Don't Save</t>",
                                onClick: (dialog, ev) => {
                                    this.$router.back();
                                }
                            },
                            {
                                text: "<t>Save</t>",
                                onClick: (dialog, ev) => {
                                    app.dialog.close()
                                    setStatus()
                                }
                            }
                        ],
                        verticalButtons: true
                    });
                    dialog.open();
                }
                // If form is empty, go back immediately
                else {
                    this.$router.back();
                }
            }
        }
    }
</script>